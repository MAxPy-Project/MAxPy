<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Basic tutorial &mdash; MAxPy 0.1 documentation</title><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Development" href="development.html" />
    <link rel="prev" title="Installation" href="installation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            MAxPy
              <img src="_static/logo-maxpy.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Basic tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-problem">The problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="#rtl-design">RTL design</a></li>
<li class="toctree-l2"><a class="reference internal" href="#converting-from-verilog-to-python">Converting from Verilog to Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="#writing-a-testbench">Writing a testbench</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exploring-approximate-arithmetic-blocks">Exploring Approximate Arithmetic Blocks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#probabilistic-pruning">Probabilistic pruning</a></li>
<li class="toctree-l2"><a class="reference internal" href="#conclusion">Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="contact.html">Contact</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MAxPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Basic tutorial</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/basic_tutorial.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="basic-tutorial">
<h1>Basic tutorial<a class="headerlink" href="#basic-tutorial" title="Permalink to this headline">¶</a></h1>
<p>This basic tutorial covers the basic functions of the MAxPy framework. By the end of it, you will be able to understand how MAxPy works and its available tools. Then, you can use the framework to develop and optimize your own circuits.</p>
<p>To follow this tutorial, you can create and edit the files as requested, or you can use the code available <a class="reference external" href="https://github.com/MAxPy-Project/MAxPy-Tutorial">here</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Basic means <em>base</em>, not <em>easy</em>! =D</p>
</div>
<div class="section" id="the-problem">
<span id="basic-tutorial-problem"></span><h2>The problem<a class="headerlink" href="#the-problem" title="Permalink to this headline">¶</a></h2>
<p>Suppose you want to make a hardware accelerator for a Polynomial Function of Degree 1: a <em>linear function</em>. The operation is pretty straightforward: the <span class="math notranslate nohighlight">\(y(x)\)</span> output for any given <span class="math notranslate nohighlight">\(x\)</span> input is the factor <span class="math notranslate nohighlight">\(a\)</span> times the <span class="math notranslate nohighlight">\(x\)</span> input plus factor <span class="math notranslate nohighlight">\(b\)</span>, as shown in the equation below.</p>
<div class="math notranslate nohighlight">
\[y(x) = a.x + b\]</div>
<p>As the equation shows, we can see that the linear function is performed by two arithmetic operations: <em>one sum</em> and <em>one multiplication</em>.</p>
<p>Now we are going to make some assumptions for our application:</p>
<ul class="simple">
<li><p>From now on, we will call our linear function circuit as <em>poly1</em>.</p></li>
<li><p>The circuit is going to have 3 inputs (<em>x</em>, <em>a</em> and <em>b</em>), and only one output (<em>y</em>);</p></li>
<li><p>Each of the three inputs will be <em>8 bits wide</em>, being the MSB the <em>signal bit</em> (values ranging from -128 to 127);</p></li>
<li><p>To cover all possibilites for data inputs, the output will be <em>16 bit wide</em>;</p></li>
<li><p>The application in which the linear function hardware accelerator will be used tolerates an error range of <em>10%</em>. To measure the error, we are going to use the <em>Mean Absolute Percentage Error</em> - the MAPE.</p></li>
</ul>
<p>Taking these assumptions into account, we can draw the following block diagram which represents our hardware accelerator:</p>
<a class="reference internal image-reference" href="_images/poly1-block.png"><img alt="_images/poly1-block.png" class="align-center" src="_images/poly1-block.png" style="width: 400px;" /></a>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="rtl-design">
<h2>RTL design<a class="headerlink" href="#rtl-design" title="Permalink to this headline">¶</a></h2>
<p>Let’s write the <em>Verilog description</em> of our linear function hardware accelerator. Create anywhere in your system a directory called <code class="docutils literal notranslate"><span class="pre">poly1</span></code>, in which will put all design files used in this tutorial. From now on, we will call this the <em>working directory</em>. Inside the working directory, create a subdirectory named <code class="docutils literal notranslate"><span class="pre">rtl</span></code>, and create a new text file called <code class="docutils literal notranslate"><span class="pre">poly1.v</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>poly1
└── rtl
    └── poly1.v
</pre></div>
</div>
<p>The following code is the hardware description of our circuit, written in Verilog:</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">poly1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="k">input</span> <span class="k">signed</span> <span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">output</span> <span class="k">signed</span> <span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">y</span><span class="p">;</span>
    <span class="k">assign</span> <span class="n">y</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="k">endmodule</span>
</pre></div>
</div>
</div>
<div class="section" id="converting-from-verilog-to-python">
<h2>Converting from Verilog to Python<a class="headerlink" href="#converting-from-verilog-to-python" title="Permalink to this headline">¶</a></h2>
<p>Now we are going to compile the <em>poly1</em> module in MAxPy, but without any optimizations or approximations for now. The goal at this point is to make a functional module that we can use to write our testbench.</p>
<p>Create a <code class="docutils literal notranslate"><span class="pre">run1.py</span></code> file inside the working directory:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>poly1
├── rtl
│   └── poly1.v
└── run1.py
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">run1.py</span></code> is a Python script, which will be used to invoke MAxPy’s command. The content of the <code class="docutils literal notranslate"><span class="pre">run1.py</span></code> is the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">MAxPy</span> <span class="kn">import</span> <span class="n">maxpy</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">maxpy</span><span class="o">.</span><span class="n">AxCircuit</span><span class="p">(</span><span class="n">top_name</span><span class="o">=</span><span class="s2">&quot;poly1&quot;</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">rtl2py</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="s2">&quot;exact&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Notice that this script performs only three commands:</p>
<ol class="arabic simple">
<li><p>It imports the MAxPy framework into Python</p></li>
<li><p>It creates an instance of <code class="docutils literal notranslate"><span class="pre">AxCircuit</span></code> class and stores it in the <code class="docutils literal notranslate"><span class="pre">circuit</span></code> object, passing the RTL design’s top circuit name to the <code class="docutils literal notranslate"><span class="pre">top_name</span></code> parameter (this is important: the top circuit name passed here <em>has to be the same</em> declared in the Verilog module)</p></li>
<li><p>It runs the <code class="docutils literal notranslate"><span class="pre">rtl2py</span></code> method to convert the RTL design into a Python module, passing the value <code class="docutils literal notranslate"><span class="pre">exact</span></code> to the <code class="docutils literal notranslate"><span class="pre">target</span></code> parameter</p></li>
</ol>
<p>Now it’s time to get MAxPy running! Run the following lines in the terminal:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python run1.py
</pre></div>
</div>
<p>If everything is fine, you should see a terminal output like the following. In case of any error, please check the <a class="reference internal" href="installation.html"><span class="doc">Installation</span></a> section and review every step of this tutorial.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>MAxPy - Version 0.0.1

------------------------------------------------------------------------------------
&gt;&gt;&gt; MAxPy rtl2py: converting Verilog RTL design &quot;poly1&quot; into Python module
&gt; Base &quot;rtl&quot;, Target &quot;exact&quot;
&gt; Start: 04-03-2023 22:48:39
&gt; Synth
&gt; Netlist estimated area: 110.887
&gt; Netlist estimated power = 5.066 uW
&gt; Netlist estimated maximum delay = 127.195 nS
&gt; Verilator
&gt; C++/Python Wrapper
&gt; C++ compilation
ninja: Entering directory `poly1_exact/&#39;
[11/11] Linking CXX shared module poly1.cpython-310-x86_64-linux-gnu.so
&gt;&gt; 3.8 seconds
&gt; Module check (should print module&#39;s name)
&gt; poly1
&gt; End: 04-03-2023 22:48:43
&gt;&gt;&gt; Circuit &quot;poly1&quot; converted successfully!
</pre></div>
</div>
<p>Let’s take a look on our <em>working directory</em> to see what changes after a successful compilation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>poly1
├── rtl
│   └── poly1.v
├── poly1_exact
│   ├── source
│   ├── netlist_yosys
│   ├── CMakeFiles
│   ├── CMakeLists.txt
│   ├── build.ninja
│   ├── *.log
│   └── poly1.cpython-310-x86_64-linux-gnu.so
└── run1.py
</pre></div>
</div>
<p>A directory named <code class="docutils literal notranslate"><span class="pre">poly1_exact</span></code> is created. Notice that this name is made combining the top name of the RTL design with the <code class="docutils literal notranslate"><span class="pre">target</span></code> parameter passed in the <code class="docutils literal notranslate"><span class="pre">rtl2py</span></code> command. Inside it there are several other files and directories:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">poly1.cpython-310-x86_64-linux-gnu.so</span></code>: this is the final product of any successful conversion of a Verilog design to Python. This <strong>.so</strong> file is a <em>shared library</em> that had been compiled based on our circuit funcionality, and then can be loaded into any Python script. Shortly we’ll check how to do so.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">netlist_yosys/</span></code>: it stores the gate-level netlist generated by the logic synthesis tool. Even if the <code class="docutils literal notranslate"><span class="pre">rtl2py</span></code> compilation is being performed in the RTL level, a gate-level netlist is generated for resources estimation purposes (area, power and timing). If no specific synthesis tool is provided, the default one is <strong>Yosys</strong>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">source/</span></code>: directory which contains the C++ source files generated from the Verilog to C++ conversion process (using <strong>Verilator</strong>), plus the C++ to Python wrapper (generated by MAxPy using <strong>Pybind11</strong>). This directory exists only for the C++ compilation process, or eventally for debugging purposes. Normally the user doesn’t need to care about it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">CMakeFiles/</span></code>, <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> and <code class="docutils literal notranslate"><span class="pre">build.ninja</span></code>: the compilation of the final Python module is performed combining <strong>CMake</strong> and <strong>ninja</strong> build system. The user shouldn’t need to care about them.</p></li>
<li><p>Log files: every step of the <code class="docutils literal notranslate"><span class="pre">rtl2py</span></code> process creates a <code class="docutils literal notranslate"><span class="pre">*.log</span></code> file with useful debug information.</p></li>
</ul>
</div>
<div class="section" id="writing-a-testbench">
<h2>Writing a testbench<a class="headerlink" href="#writing-a-testbench" title="Permalink to this headline">¶</a></h2>
<p>Now that we have a <em>shared library</em>, we are going to import it into another Python script to perform the simulation and get the evaluation of our circuit: this is the <em>testbench</em>. Create a <code class="docutils literal notranslate"><span class="pre">tesbench.py</span></code> in the <em>working directory</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>poly1
├── rtl
│   └── poly1.v
├── poly1_exact
│   ├── (...)
│   └── poly1.cpython-310-x86_64-linux-gnu.so
├── run1.py
└── testbench.py
</pre></div>
</div>
<p>Equally important as the <em>shared libraries</em> obtained from the <code class="docutils literal notranslate"><span class="pre">rtl2py</span></code> process, the testbenchs are very important in MAxPy. With them you are able to simulate your circuit operation in a Python environment without the need of a dedicated Verilog simulator. The benefits of doing so are:</p>
<ul class="simple">
<li><p>Importing and exporting data to and from the circuit is way more friendly in a Python environment than it is in dedicated Verilog simulators.</p></li>
<li><p>Use of advanced Python libraries to get quality metrics within the simulation loop.</p></li>
<li><p>Feed simulation data, such as <em>switching activity</em>, back to MAxPy to get further optimizations with <em>Approximate Computing Techniques</em>.</p></li>
<li><p>Change the circuit behaviour during simulation using the <em>cycle-accurate switching activity data</em> available in every circuit on MAxPy.</p></li>
</ul>
<p>However, the <em>testbench</em> needs to be carefully designed to meet both MAxPy’s required stucture and also the own circuit funcionality.</p>
<p>Take a look at the code from <code class="docutils literal notranslate"><span class="pre">testbench.py</span></code> showed below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">importlib</span>
<span class="kn">from</span> <span class="nn">MAxPy</span> <span class="kn">import</span> <span class="n">results</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mean_absolute_percentage_error</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mean_absolute_error</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">accuracy_score</span>

<span class="k">def</span> <span class="nf">testbench_run</span><span class="p">(</span><span class="n">ckt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">results_filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">lin</span> <span class="o">=</span> <span class="n">ckt</span><span class="o">.</span><span class="n">poly1</span><span class="p">()</span>
    <span class="n">rst</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">ResultsTable</span><span class="p">(</span><span class="n">results_filename</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;mape&quot;</span><span class="p">,</span> <span class="s2">&quot;mae&quot;</span><span class="p">,</span> <span class="s2">&quot;accuracy&quot;</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&gt;&gt;&gt; testbench init - circuit: {lin.name()}, area: </span><span class="si">{lin.area}</span><span class="s2">, parameters: </span><span class="si">{lin.parameters}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">y_true</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">y_pred</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">):</span>
        <span class="n">lin</span><span class="o">.</span><span class="n">set_a</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">):</span>
            <span class="n">lin</span><span class="o">.</span><span class="n">set_b</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">):</span>
                <span class="n">lin</span><span class="o">.</span><span class="n">set_x</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">lin</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
                <span class="n">y_out</span> <span class="o">=</span> <span class="n">lin</span><span class="o">.</span><span class="n">get_y</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">y_out</span> <span class="o">&amp;</span> <span class="mh">0x8000</span><span class="p">:</span>
                    <span class="n">y_out</span> <span class="o">^=</span> <span class="mh">0xffff</span>
                    <span class="n">y_out</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">y_out</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">y_ref</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span>
                <span class="k">if</span> <span class="n">y_ref</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">y_true</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_ref</span><span class="p">)</span>
                    <span class="n">y_pred</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_out</span><span class="p">)</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">mape</span> <span class="o">=</span> <span class="n">mean_absolute_percentage_error</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
    <span class="n">mae</span> <span class="o">=</span> <span class="n">mean_absolute_error</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
    <span class="n">accuracy</span> <span class="o">=</span> <span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
    <span class="n">rst</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lin</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;mape&quot;</span><span class="p">:</span> <span class="n">mape</span><span class="p">,</span> <span class="s2">&quot;mae&quot;</span><span class="p">:</span> <span class="n">mae</span><span class="p">,</span> <span class="s2">&quot;accuracy&quot;</span><span class="p">:</span> <span class="n">accuracy</span><span class="p">})</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&gt; mape: </span><span class="si">{mape:.4f}</span><span class="s2">, mae: </span><span class="si">{mae:.4f}</span><span class="s2">, accuracy: </span><span class="si">{accuracy:.4f}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&gt;&gt;&gt; testbench end&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mape</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">:</span>
        <span class="n">prun_flag</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">prun_flag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">prun_flag</span><span class="p">,</span> <span class="n">lin</span><span class="o">.</span><span class="n">node_info</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">mod</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;poly1_exact.poly1&quot;</span><span class="p">)</span>
    <span class="n">testbench_run</span><span class="p">(</span><span class="n">ckt</span><span class="o">=</span><span class="n">mod</span><span class="p">,</span> <span class="n">results_filename</span><span class="o">=</span><span class="s2">&quot;testbench_dev.csv&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Every testbench script should look like this one! Basically, a MAxPy testbench script has two sections: the <code class="docutils literal notranslate"><span class="pre">__main__</span></code> part at the bottom, and the <code class="docutils literal notranslate"><span class="pre">testbench_run</span></code> function.</p>
<p>The reason for putting the testbench routine in a separate function is that the function can be called when MAxPy is running its automated process (we’ll get into that shortly).</p>
<p>Also, the <em>main</em> part below is needed when we are designing the testbench itself, so once we have compiled a <em>shared library</em>, we can just run the <code class="docutils literal notranslate"><span class="pre">testbench.py</span></code> script without the needed of running the compilation again.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">__main__</span></code>: no big deal in this. It just loads a compiled <em>shared library</em> and calls the <code class="docutils literal notranslate"><span class="pre">testbench_run</span></code> function, passing the <em>shared library</em> as argument. Notice that in this tutorial we are using the <code class="docutils literal notranslate"><span class="pre">poly1_exact.poly1</span></code> compilation, but it could be any other name created in the design process.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">testbench_run</span></code>: is the testbench routine. Here some things need to happen:</p>
<blockquote>
<div><ul>
<li><p>The shared library is passed to the <code class="docutils literal notranslate"><span class="pre">testbench_run</span></code> function via the <code class="docutils literal notranslate"><span class="pre">ckt</span></code> (<em>circuit</em>) parameter. Then we need to make an object of the shred library so we can manipulate it. In this example, the object is called <code class="docutils literal notranslate"><span class="pre">lin</span></code> (for <em>linear</em>), but the can be any other.</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">testbench_run</span><span class="p">(</span><span class="n">ckt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">results_filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">lin</span> <span class="o">=</span> <span class="n">ckt</span><span class="o">.</span><span class="n">poly1</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>We need to create an object of a MAxPy internal structure for results recording. This structure is called <code class="docutils literal notranslate"><span class="pre">ResultsTable</span></code>, and it is instantiated at the <code class="docutils literal notranslate"><span class="pre">rst</span></code> object. Notice that we are passing a list of strings as arguments. Each string in this list represents a <em>quality metric</em> used in this circuit. As we stated at <a class="reference internal" href="#basic-tutorial-problem"><span class="std std-ref">the begining of this tutorial</span></a>, the chosen quality metric is the MAPE, so we are passing the <code class="docutils literal notranslate"><span class="pre">[&quot;mape&quot;]</span></code> to the <code class="docutils literal notranslate"><span class="pre">ResultsTable</span></code> object. In spite of only one quality metric being allowed, we are adding two more quality metrics: the <em>Mean Absolute Error</em> (MAE) and the <em>Accuracy Score</em>. You can add as many parameters as you want.</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">rst</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">ResultsTable</span><span class="p">(</span><span class="n">results_filename</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;mape&quot;</span><span class="p">,</span> <span class="s2">&quot;mae&quot;</span><span class="p">,</span> <span class="s2">&quot;accuracy&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>You can find information about these quality metrics in the following links:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.mean_absolute_error.html">MAPE</a></p></li>
<li><p><a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.mean_absolute_percentage_error.html">MAE</a></p></li>
<li><p><a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.accuracy_score.html">Accuracy</a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>This is a basic tutorial about how to use the MAxPy framework. The <em>polynomial function</em> application does not intend to be a real world application. Perhaps the chosen quality metrics are not the best fit for evaluating a <em>polynomial function</em>. If you have any suggestion that would fit better as example, please let us know - check the <span class="xref std std-ref">Contact</span> page.</p></li>
<li><p>To apply values to the inputs of the circuit, we must use the <code class="docutils literal notranslate"><span class="pre">set</span></code> functions. For every circuit input, MAxPy create a method in the <em>shared library</em> called <em>set_</em> plus the <em>name of the input</em>. For example, as we have instantiated our circuit at the <code class="docutils literal notranslate"><span class="pre">lin</span></code> object, we can write to the <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(b\)</span> inputs by using the following methods: <code class="docutils literal notranslate"><span class="pre">lin.set_a(value)</span></code>, <code class="docutils literal notranslate"><span class="pre">lin.set_b(value)</span></code> and <code class="docutils literal notranslate"><span class="pre">lin.set_x(value)</span></code>. The values applied to the inputs must respect the bit width. For example, for an 8 bit input, the value must be in the range from <em>0</em> to <em>255</em>. Any value outside of this range will throw an error and the execution will stop.</p></li>
<li><p>After setting all input values, it is needed to call the <code class="docutils literal notranslate"><span class="pre">lin.eval()</span></code> method. This is a default method from the <em>Verilator</em> tool. It’s purpose is to update all the circuit with the new input values, so we can get the output values.</p></li>
<li><p>To get values from outputs, we need to use the <code class="docutils literal notranslate"><span class="pre">get</span></code> methods created by MAxPy for each output. In this application, we have only the <span class="math notranslate nohighlight">\(y\)</span> output, and we can access its value using the <code class="docutils literal notranslate"><span class="pre">lin.get_y()</span></code> function. <strong>Careful attention must be payed when dealing with negative numbers</strong>. The representation used in the circuit is regarding the bit width declared in the RTL description. For example, in a signed 8 bit output, a value of <em>0x80</em> represents the <em>-128</em> value. If you use the <code class="docutils literal notranslate"><span class="pre">lin.get_y()</span></code> and load the result in an <code class="docutils literal notranslate"><span class="pre">int</span></code> variable in Python, it will be simply considered as <em>+128</em> (this happens because in 8 bit, the signal is represented in the bit number 7; in a Python application, the default <em>int</em> bit width is 32, so the signal is represented in the bit number 31). In this example, we used the following code to convert an 8 bit negative number to a 32 bit negative number:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">y_out</span> <span class="o">=</span> <span class="n">lin</span><span class="o">.</span><span class="n">get_y</span><span class="p">()</span>
<span class="k">if</span> <span class="n">y_out</span> <span class="o">&amp;</span> <span class="mh">0x8000</span><span class="p">:</span>
    <span class="n">y_out</span> <span class="o">^=</span> <span class="mh">0xffff</span>
    <span class="n">y_out</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">y_out</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>Also, regarding the <em>tesbench loop</em>, we have chosen to use all possibilities for the inputs: <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(b\)</span>, each one of them being 8 bit wide. This results in a set of 16,777,216 combinations, which may take some time to process (a few minutes) depending on the host system. Again, as this is not intended to be a real application, maybe to check every input possibilities could not be the best approach. Each application should consider which is the best way to evaluate the results.</p></li>
<li><p>The reference value is generated by the following function. Both the <code class="docutils literal notranslate"><span class="pre">y_ref</span></code> and <code class="docutils literal notranslate"><span class="pre">y_out</span></code> values are stored in separate arrays, so at the end of the loop we can use whichever method to calculate the quality metrics.</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">y_ref</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>The following section shows how a MAxPy testbench must end. The <code class="docutils literal notranslate"><span class="pre">testbench_run</span></code> function must return two values: a <em>boolean</em> flag indicating whether the circuit should be further optimized, and the node information after the simulation was performed. This return values are needed when MAxPy is running in the automated loops, so it is able to know when to stop to perform optimizations if the quality metrics had reached a lower level than expected.</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">mape</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">:</span>
    <span class="n">prun_flag</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">prun_flag</span> <span class="o">=</span> <span class="kc">False</span>
<span class="k">return</span> <span class="n">prun_flag</span><span class="p">,</span> <span class="n">lin</span><span class="o">.</span><span class="n">node_info</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="exploring-approximate-arithmetic-blocks">
<h2>Exploring Approximate Arithmetic Blocks<a class="headerlink" href="#exploring-approximate-arithmetic-blocks" title="Permalink to this headline">¶</a></h2>
<p>Now that we have a working testbench able to run a complete simulation and to generate the desired quality metrics, suppose we want to explore a little our <code class="docutils literal notranslate"><span class="pre">poly1</span></code> circuit.</p>
<p>One thing that MAxPy allows to do is to replace basic arithmetic blocks for approximate ones.</p>
<p>The <strong>MAxPy Project</strong> has a library of <em>Approximate Arithmetic blocks</em>, which is available at the <a class="reference external" href="https://github.com/MAxPy-Project/AxArith">AxArith repository</a>.</p>
<p>Now let’s get back to the <code class="docutils literal notranslate"><span class="pre">poly1</span></code> <em>working directory</em>. We are going to keep the <code class="docutils literal notranslate"><span class="pre">rtl</span></code> directory and the <code class="docutils literal notranslate"><span class="pre">run1.py</span></code> script as they are.</p>
<p>We’ll create then a new directory: the <code class="docutils literal notranslate"><span class="pre">rtl_param</span></code>. Inside this directory we’ll create a new RTL description, but with some differences that we’ll see shortly. Also, we’ll create the <code class="docutils literal notranslate"><span class="pre">run2.py</span></code> script, which is going to contain the MAxPy’s instruction for exploring arithmetic blocks.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>poly1
├── rtl
│   └── poly1.v
├── rtl_param
│   └── poly1.v
├── poly1_exact
│   └── ...
├── run1.py
└── run2.py
</pre></div>
</div>
<p>MAxPy has a feature for text replacement in <em>Verilog</em> source files. Whenever we want to evaluate any circuit with variations at some specific part, we can write the RTL source using the <code class="docutils literal notranslate"><span class="pre">[[param]]</span></code> notation. The main thing here is the double brackets (<code class="docutils literal notranslate"><span class="pre">[[</span></code> and <code class="docutils literal notranslate"><span class="pre">]</span></code>). The word <code class="docutils literal notranslate"><span class="pre">param</span></code> inside the brackets acts as a variable name. This sort of variable will be replaced for value defined in the <code class="docutils literal notranslate"><span class="pre">run2.py</span></code> script.</p>
<p>Back to the <code class="docutils literal notranslate"><span class="pre">poly1</span></code> application: it has two arithmetic operations: a multiplication and a sum.</p>
<div class="highlight-verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">poly1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="k">input</span> <span class="k">signed</span> <span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">output</span> <span class="k">signed</span> <span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">y</span><span class="p">;</span>
    <span class="kt">wire</span> <span class="k">signed</span> <span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">[[</span><span class="n">MULTIPLIER_TYPE</span><span class="p">]]</span> <span class="p">#(</span><span class="mh">16</span><span class="p">,</span> <span class="p">[[</span><span class="n">MULTIPLIER_K</span><span class="p">]])</span> <span class="n">mult1</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="p">[[</span><span class="n">ADDER_TYPE</span><span class="p">]]</span> <span class="p">#(</span><span class="mh">16</span><span class="p">,</span> <span class="p">[[</span><span class="n">ADDER_K</span><span class="p">]])</span> <span class="n">sum1</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="k">endmodule</span>
</pre></div>
</div>
<p>In the above RTL description, instead of just assigning that <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">a*x</span> <span class="pre">+</span> <span class="pre">b;</span></code>, we are spliting this line into two other: the first calls a submodule with name <code class="docutils literal notranslate"><span class="pre">[[MULTIPLIER_TYPE]]</span></code>, passing as parameters <em>16</em> as bit width and <code class="docutils literal notranslate"><span class="pre">[[MULTIPLIER_K]]</span></code> as <em>approximation factor</em>. The inputs of the multiplier submodule are connected to the <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> inputs, and the output is connected to the wire named <code class="docutils literal notranslate"><span class="pre">p</span></code>. The following lines calls another submodule called <code class="docutils literal notranslate"><span class="pre">[[ADDER_TYPE]]</span></code>, passing as parameters <em>16</em> as bit width and <code class="docutils literal notranslate"><span class="pre">[[ADDER_K]]</span></code> as <em>approximation factor</em>. The inputs of the adder submodule are connected to the <code class="docutils literal notranslate"><span class="pre">p</span></code> wire and the <code class="docutils literal notranslate"><span class="pre">b</span></code> input, while the output of this sum is connect directly to the <code class="docutils literal notranslate"><span class="pre">y</span></code> output.</p>
<p>Below we can see the <code class="docutils literal notranslate"><span class="pre">run2.py</span></code> code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">MAxPy</span> <span class="kn">import</span> <span class="n">maxpy</span>
<span class="kn">from</span> <span class="nn">testbench</span> <span class="kn">import</span> <span class="n">testbench_run</span>

<span class="n">circuit</span> <span class="o">=</span> <span class="n">maxpy</span><span class="o">.</span><span class="n">AxCircuit</span><span class="p">(</span><span class="n">top_name</span><span class="o">=</span><span class="s2">&quot;poly1&quot;</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">set_testbench_script</span><span class="p">(</span><span class="n">testbench_run</span><span class="p">)</span>

<span class="n">circuit</span><span class="o">.</span><span class="n">set_group</span><span class="p">(</span><span class="s2">&quot;study_no_1&quot;</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">set_synth_tool</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">set_results_filename</span><span class="p">(</span><span class="s2">&quot;output.csv&quot;</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;[[MULTIPLIER_TYPE]]&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;LoBa&quot;</span><span class="p">,</span> <span class="s2">&quot;Roba&quot;</span><span class="p">,</span> <span class="s2">&quot;Drum&quot;</span><span class="p">,</span> <span class="s2">&quot;Tosam&quot;</span><span class="p">],</span>
    <span class="s2">&quot;[[MULTIPLIER_K]]&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">],</span>
    <span class="s2">&quot;[[ADDER_TYPE]]&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;copyA&quot;</span><span class="p">,</span> <span class="s2">&quot;eta1&quot;</span><span class="p">,</span> <span class="s2">&quot;loa&quot;</span><span class="p">,</span> <span class="s2">&quot;trunc0&quot;</span><span class="p">],</span>
    <span class="s2">&quot;[[ADDER_K]]&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="s2">&quot;4&quot;</span><span class="p">],</span>
<span class="p">}</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">rtl2py_param_loop</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s2">&quot;rtl_param&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Please notice the following:</p>
<ul class="simple">
<li><p>Comparing to the <code class="docutils literal notranslate"><span class="pre">run1.py</span></code> script, we do not have changes until the line <code class="docutils literal notranslate"><span class="pre">circuit.set_testbench_script(testbench_run)</span></code>; here we also need to import MAxPy into Python, instantiate an MAxPy object and set the testbench script to it.</p></li>
<li><p>As we are going to compile a set of circuits for every combination of parameters, MAxPy allow to create a group using the line <code class="docutils literal notranslate"><span class="pre">circuit.set_group(&quot;study_no_1&quot;)</span></code>. This line just puts all the generated in a subdirectory called <code class="docutils literal notranslate"><span class="pre">study_no_1</span></code>. This name is arbitrary; any other name can be used to make it more significant to the application.</p></li>
<li><p>The line <code class="docutils literal notranslate"><span class="pre">circuit.set_synth_tool(None)</span></code> defines that we are not using the <em>gate-level</em> simulation in this exploration. This is a recommendation because <em>RTL-level</em> compilation and simulation is faster than gate-level. We can use the gate-level later and apply it only to the most promising circuits.</p></li>
<li><p>We can set the output file name with the line <code class="docutils literal notranslate"><span class="pre">circuit.set_results_filename(&quot;output.csv&quot;)</span></code>. Any name can be used.</p></li>
<li><p>The most important part here is the <code class="docutils literal notranslate"><span class="pre">circuit.parameters</span></code> variable. We need to initialize a <em>Python dictionary</em> with the keys containing the <strong>same names of the parameters we used in the RTL description above</strong>. For each key, the value must be a <strong>list of strings</strong> containing every value we want for each parameter to assume.</p></li>
<li><p>The command <code class="docutils literal notranslate"><span class="pre">circuit.rtl2py_param_loop(base=&quot;rtl_param&quot;)</span></code> puts MAxPy running, automaticaly generating <em>as much circuits as possible combinations for the parameters</em>.</p></li>
</ul>
<p>For the defined parameters in this example, a total of <strong>192 circuits</strong> are generated. As we have defined a group called <code class="docutils literal notranslate"><span class="pre">study_no_1</span></code>, every generated circuit is put on its own directory inside the <code class="docutils literal notranslate"><span class="pre">study_no_1</span></code> directory. The <em>working directory</em> will look like the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>poly1
├── rtl
│   └── poly1.v
├── rtl_param
│   └── poly1.v
├── poly1_exact
│   └── ...
├── study_no_1
│   ├── poly1_LoBa_1_copyA_1
│   ├── poly1_LoBa_1_copyA_2
│   ├── poly1_LoBa_1_copyA_3
│   ├── poly1_LoBa_1_copyA_4
│   ├── poly1_LoBa_1_eta1_1
│   ├── poly1_LoBa_1_eta1_2
│   ├── poly1_LoBa_1_eta1_3
│   ├── poly1_LoBa_1_eta1_4
│   └── ...
├── run1.py
└── run2.py
</pre></div>
</div>
</div>
<div class="section" id="probabilistic-pruning">
<h2>Probabilistic pruning<a class="headerlink" href="#probabilistic-pruning" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>The script names <code class="docutils literal notranslate"><span class="pre">run1.py</span></code>, <code class="docutils literal notranslate"><span class="pre">run2.py</span></code> and <code class="docutils literal notranslate"><span class="pre">run3.py</span></code> are completely arbitrary. You can choose any name you want to match what the script does.</p></li>
</ul>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="installation.html" class="btn btn-neutral float-left" title="Installation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="development.html" class="btn btn-neutral float-right" title="Development" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, MAxPy Project.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>